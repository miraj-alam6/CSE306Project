Miraj Alam, Kwun Chan

Quicklist of files that were dealt with
Under nachos.kernel.filesys.test
MultiFileSysteTest.java
ReadSectorTest.java

Under nachos.kernel.devices
DiskDriver
WorkEntry

Under nachos.kernel.filesys
FileSystemReal

README Section 1: Overview:

In this project, we made disk scheduling using FCFS and CSCAN heuristics.
The code for this can be seen in the WorkEntry class and the DiskDriver
class, both of them are under the nachos.kernel.devices package.


We used an arraylist for the WorkQueue. All jobs when they are processed
block with their own semaphore, except if the diskDriver is not busy, then,
it does a read/write request as well as the semaphore. 

The interrupt handler works as such: first it gets whichever job is currently
running, and does a semaphore.V of it to finish that process. Then it gets 
the next job from the queue and does a semaphore to that job's semaphore. 
And then does either a read or write request based on what type the job is. 
Once this request completes, the interrupt handler occurs again and it starts
over.


For the FCFS heuristic, the first
element of the WorkQueue arraylist is used as the next process. 

For the CSCAN heuristic, the element of the WorkQueue arraylist that is
used is the element that has disk sector number closest to the head
in the direction of increasing sector # as in, it simulates CSCAN by taking
whatever job is closest as it moves to one end. And then if it goes past all
the jobs, then it resets the head. The head is always set when the semaphore
V occurs in the interrupt handler because the head is at where the last 
run job was.

For the FCFS heuristic, adding a job to the workqueue works by adding to the
end of the arraylist.

For the CSCAN heuristic, adding a job to the workqueue works by looping through
the array list and inserting the job in the correct place such that the 
arraylist is sorted by their disk position based on sector number. Since
each and every job in the workqueue is added like this, it will always be
sorted.


README Section 2: How to compile and test:
Both FCFS and CSCAN work, but CSCAN does not seem to be faster as was intended.


Do these run configurations in a row
-mfst -dscfs -f -cptest -d z OR -mfst -dscfs -f -cptest 
-mfst -l -D 

And then do these two run configurations in a row
-mfst -dscscan -f -cptest -d z or -mfst -dscfs -f -cptest
-mfst -l -D
The -d z adds extra debugging output that demonstrate how the indices
are correctly different for the next process.

MultiFileSystemTest in nachos.kerenl.filesys.test is what is
activated by -mfst. -dsfcfs uses the first come first serve scheduling
heuristic, while -dscscan uses the CSCAN scheduling heuristic.
-cptest makes the test program created 8 different Nachos files by calling 
copy from 8 different threads. One of threads files copies halt.c from the 
test folder, and the other 7 copy halt executable from the test folder. 

You should see that both tests result in all 8 files being created
and both times there is no file corruption. There is 1 file
that is the text of halt.c, while the other 7 are consistently the
same binary code, which can be tested by doing something like
-mfst -x file_5

The read test shows a difference between CSCAN and FCFS times, but it seems
CSCAN is slower. This may be because of the overhead of CSCAN and how an
ArrayList is probably an inefficient data structure.
Run the test by doing
-rst -dsfcfs
-rst -dscscan


README Section 3: Our Assumptions

We ask that you look at our code for WorkEntry and DiskDriver, furthermore
the debug messages are there to show that certain parts of the scheduling 
heuristics are definitely working, as in how the CSCAN heuristic places
the job correctly into a list in such a way that the list is sorted by
disk position based on sector.  

