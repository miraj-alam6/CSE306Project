Miraj Alam, Kwun Chan

README Section 1: Overview:

In this project, we created the scheduling policies of First-Come-First-Serve(FCFS),
Shortest Job First(SJF), Shortest Remaining Time(SRT), Round-Robin(RR),
Highest Response Ratio Next(HRRN), and Feedback Scheduling (FBS).
Test programs were made do demonstrate the functionality of each of the scheduling
policies that were implemented. 

A test program was also made to try to replicate the Stalling graphs. The extent
to how much of this was implemented will be elaborated later. 

Part 1: All scheduling policies were implemented. The
main idea was that there is a list of user processes, and this list is contained
in a class that finds the next process in different ways for each of the scheduling
policies. This is achieved by making UPList an interface, and then each of the
scheduling policies implements that interface. All these classes can be found
in the userprog package.


Part 2: Test program was created and new processes were created periodically
to run this program with randomness for the amount of iterations of the loop
in the test program were done.


README Section 2: How to compile and test:

ROUGH:

use -xc instead of -x for the programs so that the console stays open after
execution
Run a program as such: 

-x test/hw3testprog1 -fcfs

Where the last parameter can be any scheduling policy where -fcfs is
just one of the options.
The different options are

-fcfs, -sjf, -srt, -hrrn, -rr, -fbs.
I will now list tests with specifed scheduling polices that demonstrated clearly
how the scheduling policies are working because of the correctly different output
for the same tests for different scheduling policies. These are just recommended
tests that demonstrate clear differences; obviously one can choose any
scheduling policy for any of the tests by simply putting the corresponding flag.
For each of the tests I am specifying, there will be one test per line, and
you can simply copy and paste all the arguments into the argument list and the
test will be carried out with the scheduling policy as specified by the
last parameter on each line.

hw3testprog1 demonstrates difference between fcfs and sjf and rr, you can look
at the code for each of the c files which in turn execute other c files
where if you look at the code for those it will help demonstrate what I've done.
Under round robin it will preempt and runs it like a fcfs. NOTE: If you see that
1_2 message comes before 1_1 in round robin that does not mean that the program
for 1_2 ran first, the program runs a bit before the first message is even printed
thus round robin will preempt 1_1 before 1_1 can print its first message sometimes.
You can simply mess around and change the quantum size in Scheduler, it is
a field name QUANTUMT. By messing around with quantum size it is clear that
round robin is definitely working.

-xc test/hw3testprog1 -fcfs
-xc test/hw3testprog1 -sjf
-xc test/hw3testprog1 -rr


hw3testprog2 demonstrates a case where -sjf and -hrrn will be give different
output, thus demonstrating hrrn working because it calls 2_2 before 2_3 with
how the code currently is. But if you change the code in hwtestprog2_2, and 
make the predictCPU significantly larger, 2_3 will run before 2_2 because the
ratio is determined by both waiting time and the cpu burst time, thus hrrn is
indeed working. These are the arguments lists that you should use:

-xc test/hw3testprog2 -sjf
-xc test/hw3testprog2 -hrrn

hw3testprog3 demonstrates how -sjf and -srt will give different output such that
it demonstrates both policies are doing what they should do correctly.
hw3testprog3 is run first, and inside it, it has two loops, and in between the
two of them it creates two processes, one with a bigger cpu burst time than itself
and one with a much smaller cpu burst time. In srt it rightfully preempts to
this smaller process, while in sjf before doing the second loop, but in sjf it
runs hwtestprog3 to completion and then runs the shortest process waiting to be
run. Here are the arguments lists:

-xc test/hw3testprog3 -sjf 
-xc test/hw3testprog3 -srt

To test FBS:
Can try any of the first three programs using -fbs in arguments

-xc test/hw3testprog1 -fbs
-xc test/hw3testprog2 -fbs
-xc test/hw3testprog3 -fbs

We created a bunch of test programs in C that have been compiled and included in the test directory. We expanded 
upon the code for ProgTest, and that is what is used to execute the first program which then executes its own code 
which in these tests often consist of calling exec("anothertestprogram"). We also made a class called ConsoleProgTest 
where the console runs on a separate thread, thus it doesn't automatically close as soon as something is written to it.
-x is the flag for turning on ProgTest, and it takes an argument for the filepath
-xc is the flag for turning on ConsoleProgTest,  and it takes an argument for the filepath
I will elaborate more on the difference between -x and -xc later in section 3: assumptions so please read that to understand how to 
use the flags. These are the arguments lists that you should use:

Each of them are in the test directory

Here is what each of them do, if you want to read the source code, open the .c files for each of these
program names.

testprog1: this one simply is a program that does the yield system call 3 times. You can see this in the 
debugging messages in java console in eclipse. Thus -x is good enough, because no console is necessary (More 
elaboration in Section 3 of README)

testprog2: this one does exec(testprog1) TWICE, thus, each of the two processes will keep yield thrice and the
scheduler keeps switching between them, thus showing that concurrency works, and the yield system call works. This
test also shows that the exec system call works, thus the Address Space uses address translation correctly with a proper
page table and code loading.

testprog3: this program simply writes to the console, but it does writing a string that was defined in the data section. 
It's better to use consoleprogtest for this, it works for both, but I'll elaborate in the assumptions section why it's 
better to use consoleprogtest

testprog4: this program simply executes testprog3 thus showing that data section translation indeed works.

testprog5: this program shows that the join system call works because a message is printed after join. It's better to use consoleprogtest for this, it works for both, but I'll elaborate in the assumptions section why it's better to use 
consoleprogtest.

testprog6: this program shows that read works, by reading in what you type with a max buffer size of 25, and then 
printing out what was read by using the write system call on the same buffer that was read into in the C file. Even 
though a console will show up in this program, it is important to use -x instead of -xc(I will explain in Section 3 of README)

Debug Flags:
-w flag gets extra output that specifiy page allocation
-z flag gets extra miscellaneous output

Run each of the programs by putting this into the Run Configuration Arguments

-x test/testprog1
-x test/testprog2
-xc test/testprog3
-xc test/testprog4
-xc test/testprog5
-x test/testprog6


README Section 3: Our Assumptions
You run each of the programs doing
One big assumption for this code is that the code that is executed by exec(), will run. Nachos doesn't crash if an
invalid program name is provided, but if the code itself has a big issue, that was not tested.

These are the assumptions of why you should use -x vs -xc or vice versa for each of the specific tests:

testprog1 and testprog2 you do -x because no console is needed
testprog3 testprog4 and testprog5 work fine with -x but it's better to do -xc because the console does not automatically
close so you have enough time to actually read what's on the console.
testprog6 -xc is not good because, while it still technically works, it definitely doesn't immediately get input for Read
system call because the console takes in what you write for the first time and press enter as something that the console 
itself has, AND then the next thing that you type is what actually gets read into the console. And then the program works
as expected.This weirdness is because the console is running on a different thread. So it's better to do -x, because the 
first thing that you type is read into it as expected and that is what is put into the buffer that is written to the console.

We assume that the machine would be restarted between tests so that the arguments in run configurations can be changed to
start a different test.