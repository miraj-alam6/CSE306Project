Miraj Alam, Kwun Chan

Quicklist of the arguments to test:
FOR PART 1:
-xc test/hw3testprog1 -fcfs
-xc test/hw3testprog2 -fcfs
-xc test/hw3testprog3 -fcfs
Where -fcfs can be replaced with any of the other scheduling policies 
FOR PART 2:
To see stallings results:
-slt -fcfs
Where -fcfs can be replaced with any of the other scheduling policies 
-slt creates a testprogram that waits and randomly creates executions of
test/hw3testprog4 which is the loop using for Stallings.
The graph result is StallingsGraphImage.png in the top level folder


README Section 1: Overview:

In this project, we created the scheduling policies of First-Come-First-Serve(FCFS),
Shortest Job First(SJF), Shortest Remaining Time(SRT), Round-Robin(RR),
Highest Response Ratio Next(HRRN), and Feedback Scheduling (FBS).
Test programs were made do demonstrate the functionality of each of the scheduling
policies that were implemented. 

A test program was also made to try to replicate the Stalling graphs. The extent
to how much of this was implemented will be elaborated later. 

Part 1: All scheduling policies were implemented. The
main idea was that there is a list of user processes, and this list is contained
in a class that finds the next process in different ways for each of the scheduling
policies. This is achieved by making UPList an interface, and then each of the
scheduling policies implements that interface. All these classes can be found
in the userprog package.


Part 2: Test program was created and new processes were created periodically
to run this program with randomness for the amount of iterations of the loop
in the test program were done. 

ALL THE FILES CREATED ARE IN nachos.kernel.userprog, they are:
FCFSQueue,SJFQueue ,HRRNQueue,FBSQueue, UPList, StallingsHelper
Changes were also made to UserThread, Scheduler, Nachos, Options, and probably others.

README Section 2: How to compile and test:

ROUGH:

use -xc instead of -x for the programs so that the console stays open after
execution
Run a program as such: 

-x test/hw3testprog1 -fcfs

Where the last parameter can be any scheduling policy where -fcfs is
just one of the options.
The different options are

-fcfs, -sjf, -srt, -hrrn, -rr, -fbs.
I will now list tests with specifed scheduling polices that demonstrated clearly
how the scheduling policies are working because of the correctly different output
for the same tests for different scheduling policies. These are just recommended
tests that demonstrate clear differences; obviously one can choose any
scheduling policy for any of the tests by simply putting the corresponding flag.
For each of the tests I am specifying, there will be one test per line, and
you can simply copy and paste all the arguments into the argument list and the
test will be carried out with the scheduling policy as specified by the
last parameter on each line.




hw3testprog1 demonstrates difference between fcfs and sjf and rr, you can look
at the code for each of the c files which in turn execute other c files
where if you look at the code for those it will help demonstrate what I've done.
Under round robin it will preempt and runs it like a fcfs. NOTE: If you see that
1_2 message comes before 1_1 in round robin that does not mean that the program
for 1_2 ran first, the program runs a bit before the first message is even printed
thus round robin will preempt 1_1 before 1_1 can print its first message sometimes.
You can simply mess around and change the quantum size in Scheduler, it is
a field name QUANTUMT. By messing around with quantum size it is clear that
round robin is definitely working.

-xc test/hw3testprog1 -fcfs
-xc test/hw3testprog1 -sjf
-xc test/hw3testprog1 -rr


hw3testprog2 demonstrates a case where -sjf and -hrrn will be give different
output, thus demonstrating hrrn working because it calls 2_2 before 2_3 with
how the code currently is. But if you change the code in hwtestprog2_2, and 
make the predictCPU significantly larger, 2_3 will run before 2_2 because the
ratio is determined by both waiting time and the cpu burst time, thus hrrn is
indeed working. These are the arguments lists that you should use:

-xc test/hw3testprog2 -sjf
-xc test/hw3testprog2 -hrrn

hw3testprog3 demonstrates how -sjf and -srt will give different output such that
it demonstrates both policies are doing what they should do correctly.
hw3testprog3 is run first, and inside it, it has two loops, and in between the
two of them it creates two processes, one with a bigger cpu burst time than itself
and one with a much smaller cpu burst time. In srt it rightfully preempts to
this smaller process, while in sjf before doing the second loop, but in sjf it
runs hwtestprog3 to completion and then runs the shortest process waiting to be
run. Here are the arguments lists:

-xc test/hw3testprog3 -sjf 
-xc test/hw3testprog3 -srt

To test FBS:
Can try any of the first three programs using -fbs in arguments. To change the quantum of each queue in for feedback scheduling,
change the values in the array in FBSQueue.java

PART 2:
You can see the process with which we made our graph.
To see the programs infinitely run, and the statistics from these programs do these:

-slt -fcfs
-slt -sjf
-slt -srt
-slt -hrrn
-slt -rr

As you can see, no longer using -x or -xc, because this is a different test where it runs infinitely, with random ticks, which is
calculated as specified by the assignment description.

Look at the picture of the graph the name of the file is StallingsGraphImage.png


where you can replace -fcfs with any scheduling policy


README Section 3: Our Assumptions

Many times the program won't terminate, this is because we didn't have enough time to properly turn off all the timers.
So we're assuming that if the program doesn't terminate to just click the stop button in eclipse to stop it, or just run the program again
to do a different test.
Another thing we are assuming is that for all the tests in part 2 that you will
be using the Nachos console  that shows up to quickly see all the things that are 
printed, you can also look at the the messages in the eclipse console, but the
eclipse console is a bit more dense and simply tells you when a syscall is called
rather than what it actually printed on the console.

ANOTHER assumption about the console: We are assuming that you wait a while
when testing the programs for output to show up on the screen. On many of these
programs, long loops are executed, and then a message is show at the end of the
loop, because it would be too messy to keep printing every iteration of the
loop.